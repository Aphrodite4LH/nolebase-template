# 541.反转字符串Ⅱ
## 题目

### 题目链接
[541. 反转字符串 II - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-string-ii/submissions/549321142/)

### 题目描述
给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。

- 如果剩余字符少于 `k` 个，则将剩余字符全部反转。
- 如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。

### 示例
- 示例一
```text
输入：s = "abcdefg", k = 2
输出："bacdfeg"
```
- 示例二
```text
输入：s = "abcd", k = 2
输出："bacd"
```

### 提示
- `1 <= s.length <= 10^4`
- `s` 仅由小写英文组成
- `1 <= k <= 10^4`

## 解答

```Cpp
class Solution {
   public:
    void reverseByRange(string& s, int start, int end) {
        while (start < end) {
            char temp  = s[start];
            s[start++] = s[end];
            s[end--]   = temp;
        }
    }
    string reverseStr(string s, int k) {
        int size       = s.size();
        int rangeStart = 0;
        int rangeEnd   = 2 * k;
        // 每次开辟2k的range
        while (rangeEnd <= size) {
            reverseByRange(s, rangeStart, rangeStart + k - 1);
            rangeStart = rangeEnd;
            rangeEnd += 2 * k;
        }
        // 如果rangeEnd已经超过了尾部，判断rangeStart后是否有k个元素剩余，分类讨论
        if (rangeStart + k - 1 <= size - 1) {
            reverseByRange(s, rangeStart, rangeStart + k - 1);
        }
        else {
            reverseByRange(s, rangeStart, size - 1);
        }
        return s;
    }
};
```

>[!note] 复杂度
>时间复杂度为：$O(n)$
>
>空间复杂度为：$O(1)$


## 解析

思路很清晰，没啥好解析的，贴一下标答
```Cpp
class Solution {
public:
    string reverseStr(string s, int k) {
        for (int i = 0; i < s.size(); i += (2 * k)) {
            // 1. 每隔 2k 个字符的前 k 个字符进行反转
            // 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符
            if (i + k <= s.size()) {
                reverse(s.begin() + i, s.begin() + i + k );
            } else {
                // 3. 剩余字符少于 k 个，则将剩余字符全部反转。
                reverse(s.begin() + i, s.end());
            }
        }
        return s;
    }
};
```
