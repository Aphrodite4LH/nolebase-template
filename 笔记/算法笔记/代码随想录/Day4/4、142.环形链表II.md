# 142.环形链表II
## 题目

### 题目链接
[142. 环形链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle-ii/)

### 题目描述
给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 _如果链表无环，则返回 `null`。_

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改** 链表。

- 示例一
![[../../../../images/Pasted image 20240720193259.png]]
```text
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```
- 示例二
![[../../../../images/Pasted image 20240720193318.png]]
```text
输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
```
- 示例三
![[../../../../images/Pasted image 20240720193345.png]]
```text
输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
```



## 解答

```Cpp
class Solution {
   public:
    ListNode* detectCycle(ListNode* head) {
        ListNode* slow = head;
        ListNode* fast = head;
        int sign       = 0;
        // 使用快慢指针看两个指针是否相遇，即是否有环，使用sign记录结果
        while (fast != nullptr && fast->next != nullptr) {
            slow = slow->next;
            fast = fast->next->next;
            if (fast == slow) {
                sign = 1;
                break;
            }
        }
        // 如果没有环，则返回nullptr
        if (sign == 0) {
            return nullptr;
        }
        // 如果有环，则让两个指针从头节点以及相遇点同时出发，它们的相遇点即为环起点
        else {
            ListNode* start = head;
            ListNode* meet  = fast;
            while (start != meet) {
                start = start->next;
                meet  = meet->next;
            }
            return meet;
        }
    }
};
```

>[!tip] 复杂度
>时间复杂度为：$O(n)$
>
>空间复杂度为：$O(1)$


## 解析

>使用快慢指针即可判断是否有环

这是因为`fast`是走两步，`slow`是走一步，**其实相对于slow来说，fast是一个节点一个节点的靠近slow的**，所以如果有环，`fast`一定可以和`slow`重合。

>如何得知环起点的位置？

![[../../../../images/Pasted image 20240720194439.png]]
相遇时： slow指针走过的节点数为: `x + y`， fast指针走过的节点数：`x + y + n (y + z)`，n为fast指针在环内走了n圈才遇到slow指针，(y+z)为一圈内节点的个数。

因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 = slow指针走过的节点数 * 2：

`(x + y) * 2 = x + y + n (y + z)`

两边消掉一个(x+y): `x + y = n (y + z)`

因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。

所以要求x ，将x单独放在左面：`x = n (y + z) - y` ,

再从n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：`x = (n - 1) (y + z) + z` 注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。
$$
x=(n-1)(y+z)+z
$$
这个公式说明，`x`的长度就等于`n-1`个环的长度再加上`z`

也就是说**从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点**。