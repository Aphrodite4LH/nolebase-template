# 1.两数之和
## 题目

### 题目链接
[1. 两数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum/description/)

### 题目描述
给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** _`target`_  的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

### 示例
- 示例一
```text
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```
- 示例二
```text
输入：nums = [3,2,4], target = 6
输出：[1,2]
```
- 示例三
```text
输入：nums = [3,3], target = 6
输出：[0,1]
```

### 提示
- `2 <= nums.length <= 10^4`
- `-10^9 <= nums[i] <= 10^9`
- `-10^9 <= target <= 10^9`
- **只会存在一个有效答案**

## 解答

```Cpp
class Solution {
   public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> mapping;
        for (int i = 0; i < nums.size(); i++) {
            int temp    = target - nums[i];
            auto search = mapping.find(temp);
            // 如果有能与自己组成target的值，则直接返回
            if (search != mapping.end()) {
                return vector<int>{search->second, i};
            }
            // 如果没出现过能与自己组成target的值，则将自己存入map
            else {
                mapping.insert(pair<int, int>(nums[i], i));
            }
        }
        return vector<int>{};
    }
};
```

>[!tip] 复杂度
>时间复杂度为：$O(n)$
>
>空间复杂度为：$O(n)$


## 解析


>为什么使用`unordered_map`？

本题我们不仅要知道元素有没有遍历过，还要知道这个元素对应的下标，**需要使用 key value结构来存放，key来存元素，value来存下标，那么使用map正合适**。

**这道题目中并不需要key有序，选择std::unordered_map效率更高！**

>`map`使用要点

- 使用`find()`寻找对应的`key`
```Cpp
auto search = mapping.find(temp);
```
`search`的类型为`std::unordered_map<int, int>::iterator`，不如直接`auto`

如果没找到，则`search`也会指向`mapping.end()`

---

- 给`map`添加项
```Cpp
mapping.insert(pair<int, int>(nums[i], i));
```
需要使用`pair`才行