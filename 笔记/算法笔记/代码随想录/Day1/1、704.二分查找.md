# 704.二分查找




## 题目
题目链接：[704. 二分查找 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-search/)
![[../../../../images/Pasted image 20240718004149.png]]

## 我的解答

```Cpp hl:6,8-9,11-12
class Solution {
   public:
    int search(vector<int>& nums, int target) {
        int size = nums.size();
        int left = 0, right = size, mid;
        while (left < right) { // 为什么是< 而不是<=
            mid = left + (right - left) / 2;
            if (target < nums[mid]) { //是 < 还是 <= 呢
                right = mid;// 是=mid 还是=mid-1
            }
            else if (nums[mid] < target) { //是 < 还是 <= 呢
                left = mid + 1; //是=mid 还是 =mid+1
            }
            else if (nums[mid] == target) {
                return mid;
            }
        }
        return -1;
    }
};
```

>[!tip] 复杂度
>时间复杂度：`O(log n)`
>
>空间复杂度：`O(1)`

我的方法中定义 target 是在一个在**左闭右开**的区间里，也就是\[left, right) ，那么二分法的边界处理方式需要注意如下几点：

- 第10行`while (left < right)`，这里使用 `<` ,因为`left == right`在区间\[left, right)是没有意义的
- `target < nums[mid]`时，`right` 更新为 `mid`，因为当前`nums[mid]`不等于`target`，而寻找区间是左闭右开，下一个查询区间不应该比较`nums[mid]`
- `nums[mid] < target`时，`left`更新为`target+1`，因为当前的`nums[mid]`不等于`target`，而寻找区间是左闭右开，下一个查询区间我们不应该去考虑当前的`nums[mid]`，而是应该考虑`nums[mid+1]`

**其实就是将区间的定义当作一个不变量，即将左闭右开贯彻始终**