# 150. 逆波兰表达式求值
## 题目

### 题目链接
[150. 逆波兰表达式求值 - 力扣（LeetCode）](https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/)

### 题目描述
给你一个字符串数组 `tokens` ，表示一个根据 [逆波兰表示法](https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437) 表示的算术表达式。

请你计算该表达式。返回一个表示表达式值的整数。

**注意：**

- 有效的算符为 `'+'`、`'-'`、`'*'` 和 `'/'` 。
- 每个操作数（运算对象）都可以是一个整数或者另一个表达式。
- 两个整数之间的除法总是 **向零截断** 。
- 表达式中不含除零运算。
- 输入是一个根据逆波兰表示法表示的算术表达式。
- 答案及所有中间计算结果可以用 **32 位** 整数表示。

### 示例
- 示例一
```text
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
```
- 示例二
```text
输入：tokens = ["4","13","5","/","+"]
输出：6
解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
```
- 示例三
```text
输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
输出：22
解释：该算式转化为常见的中缀算术表达式为：
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
```

### 提示
- `1 <= tokens.length <= 10^4`
- `tokens[i]` 是一个算符（`"+"`、`"-"`、`"*"` 或 `"/"`），或是在范围 `[-200, 200]` 内的一个整数

## 解答

```Cpp hl:18-19,33-34
class Solution {
   public:
    int evalRPN(vector<string>& tokens) {
        stack<int> resultStack;
        for (string s : tokens) {
            if (s == "+") {
                int a = resultStack.top();
                resultStack.pop();
                int b = resultStack.top();
                resultStack.pop();
                resultStack.push(a + b);
            }
            else if (s == "-") {
                int a = resultStack.top();
                resultStack.pop();
                int b = resultStack.top();
                resultStack.pop();
                // 注意顺序：是b - a
                resultStack.push(b - a);
            }
            else if (s == "*") {
                int a = resultStack.top();
                resultStack.pop();
                int b = resultStack.top();
                resultStack.pop();
                resultStack.push(a * b);
            }
            else if (s == "/") {
                int a = resultStack.top();
                resultStack.pop();
                int b = resultStack.top();
                resultStack.pop();
                // 注意顺序：是b / a
                resultStack.push(b / a);
            }
            else {
                resultStack.push(stoi(s));
            }
        }
        return resultStack.top();
    }
};
```

>[!note] 复杂度
>时间复杂度为：$O(n)$
>
>空间复杂度为：$O(n)$


## 解析

注意代码高亮处即可
