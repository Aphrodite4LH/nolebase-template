
# 浏览器解析URL

![URL 解析](1720194377-5f5b64a4e0de59fa42d07f105ef55086.jpg)

==图中的长长的 URL 实际上是请求服务器里的文件资源。==

---
# 生成HTTP消息

对 `URL` 进行解析之后，浏览器确定了 Web 服务器名和文件名，接下来就是根据这些信息来生成 HTTP 请求消息了。
![HTTP 的消息格式](1720194377-00ac30d6265b7922d5e0ad1e15c648ac.jpg)

---
# DNS查询服务器域名对应的IP地址(先尝试缓存)

浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给 `Web` 服务器。

但在发送之前，还有一项工作需要完成，那就是**查询服务器域名对应的 IP 地址**，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。

DNS 中的域名都是用**句点**来分隔的，比如 `www.server.com`，这里的句点代表了不同层次之间的**界限**。在域名中，**越靠右**的位置表示其层级**越高**。

实际上域名最后还有一个点，比如 `www.server.com.`，这个最后的一个点代表根域名。

也就是，`.` 根域是在最顶层，它的下一层就是 `.com` 顶级域，再下面是 `server.com`。

所以域名的层级关系类似一个树状结构：

*   根 DNS 服务器（.）
*   顶级域 DNS 服务器（.com）
*   权威 DNS 服务器（server.com）

![DNS 树状结构](1720194377-7ce64667aef2f0cd39b29a37bf2ba60c.jpg)

所有DNS服务器都存储了根 DNS 服务器（.）的信息

客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。

> 域名解析的工作流程

1.  客户端首先会发出一个 DNS 请求，问 www.server.com 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。
2.  本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 www.server.com ，则它直接返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 www.server.com 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。
3.  根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“ www.server.com 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”
4.  本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 www.server.com 的 IP 地址吗？”
5.  顶级域名服务器说：“我给你负责 www.server.com 区域的权威 DNS 服务器的地址，你去问它应该能问到”。
6.  本地 DNS 于是转向问权威 DNS 服务器：“老三， www.server.com 对应的IP是啥呀？” server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。
7.  权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。
8.  本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。

整个过程：**只指路不带路**

>缓存问题

==浏览器==会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，==操作系统==也会去看自己的缓存，如果有，就直接返回，如果没有，再去 ==hosts 文件==看，也没有，才会去问「本地 DNS 服务器」。

---
# 协议栈

![](1720194377-0f8b03a1991452fd0d3bd5dd1373a09a.jpg)

==应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作==。

协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，这两个传输协议会接受应用层的委托执行收发数据的操作。

协议栈的下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。

此外 IP 中还包括 `ICMP` 协议和 `ARP` 协议。
*   `ICMP` 用于告知网络包传送过程中产生的错误以及各种控制信息。
*   `ARP` 用于根据 IP 地址查询相应的以太网 MAC 地址。

# TCP（端口到端口）（传输层）

> TCP 包头格式

我们先看看 TCP 报文头部的格式：

![TCP 包头格式](1720194377-7b7db05f959cf755c738a651a10e039a.jpg)

首先，==**源端口号**和**目标端口**号是不可少的==，如果没有这两个端口号，数据就不知道应该发给哪个应用。

接下来有包的**序**号，这个是为了==解决包乱序==的问题。

还有应该有的是**确认号**，目的是确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送达，这个是为了==解决丢包==的问题。

接下来还有一些**状态位**。例如 `SYN` 是发起一个连接，`ACK` 是回复，`RST` 是重新连接，`FIN` 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。

还有一个重要的就是**窗口大小**。TCP 要做==**流量控制**==，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。

除了做流量控制以外，TCP还会做==**拥塞控制**==，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。

> TCP 传输数据之前，要先三次握手建立连接


![TCP 三次握手](1720194377-a1caae677ce0df25d7547035fe1947ea.png)
三次握手==目的是**保证双方都有发送和接收的能力**==。

> TCP 分割数据

如果 HTTP 请求消息比较长，超过了 `MSS` 的长度，这时 TCP 就需要把 HTTP 的数据拆解成一块块的数据发送，而不是一次性发送所有数据。

![MTU 与 MSS](1720194377-7e6a36857ae4e23b1225b4f16ab52afd.jpg)

*   `MTU`：一个网络包的最大长度，以太网中一般为 `1500` 字节。
*   `MSS`：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。

数据会被以 `MSS` 的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在==每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据==。

![数据包分割](1720194377-f161f04d7f3952d5a84247cb30ef5f88.jpg)

---
# IP（网络层）
![[Pasted image 20240708170547.png|400]]

>假设客户端有多个网卡，就会有多个 IP 地址，那 IP 头部的源地址应该选择哪个 IP 呢？

这个判断相当于在多块网卡中判断应该使用哪个一块网卡来发送包。
这个时候就需要根据**路由表**规则，来判断哪一个网卡作为源地址 IP。
![[Pasted image 20240708170733.png]]
根据目标IP地址，与子网掩码相与之后与 `Destination` 比较，从而选择是通过哪个网卡进行发送（最后一列）。同时也能知道下一跳去到哪里（即网关 `Gateway` ）

---
# MAC（两点传输）
![[Pasted image 20240708171024.png|400]]
发送方的`MAC`地址是在网卡生产时写入到 `ROM` 里的

要获取接收方的`MAC`地址，需要查路由表获取下一跳的`IP地址`，然后通过`ARP`协议得知下一跳的`MAC`地址。

---
# 网卡

网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将**数字信息转换为电信号**，才能在网线上传输，也就是说，这才是真正的数据发送过程。

负责执行这一操作的是**网卡**，要控制网卡还需要靠**网卡驱动程序**。

网卡驱动获取网络包之后，会将其**复制**到网卡内的缓存区中，接着会在其**开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列**。
![[Pasted image 20240708171724.png]]

---
# 交换机

交换机的设计是将网络包**原样**转发到目的地。交换机工作在 MAC 层，也称为**二层网络设备**。

首先，电信号到达网线接口，交换机里的模块进行接收，接下来==交换机里的模块将电信号转换为数字信号==。

然后==通过包末尾的 `FCS` 校验错误==，如果没问题则放到缓冲区。这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。

计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，==交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，**交换机的端口不具有 MAC 地址**。==

将包存入缓冲区后，接下来需要查询一下这个包的接收方 MAC 地址是否已经在 ==MAC 地址表==中有记录了。
![[Pasted image 20240708172544.png|400]]
交换机的 MAC 地址表主要包含两个信息：

- 一个是设备的 MAC 地址，
- 另一个是该设备连接在交换机的哪个端口上。

---
# 路由器(走出子网)

**路由器**是基于 IP 设计的，俗称**三层**网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；

> 路由器基本原理

路由器的端口具有 MAC 地址，因此它就能够成为以太网的发送方和接收方；同时还具有 IP 地址，从这个意义上来说，它和计算机的网卡是一样的。

当转发包时，首先路由器端口会接收发给自己的以太网包，然后**路由表**查询转发目标，再由相应的端口作为发送方将以太网包发送出去。

> 路由器的包接收操作

首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 `FCS` 进行错误校验。

如果没问题则检查 MAC 头部中的**接收方 MAC 地址**，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。

总的来说，==路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包==，遇到不匹配的包则直接丢弃。


完成包接收操作之后，路由器就会**去掉**包开头的 MAC 头部。

**MAC 头部的作用就是将包送达路由器**，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会**被丢弃**。

然后重新查询路由表得到下一跳的IP，通过ARP得到下一跳的MAC地址，然后打包发送

==在网络包传输的过程中，**源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址**，因为需要 MAC 地址在以太网内进行**两个设备**之间的包传输。==

# 浏览器解析响应并渲染页面


### 1. **解析响应头**

当浏览器收到服务器的响应时，它首先会解析响应头部信息。响应头包含了很多重要的元数据，例如状态码、内容类型、缓存策略等。

- **状态码**：例如，200表示请求成功，301或302表示重定向。
- **内容类型**：如 `text/html` 表示HTML文档，`application/json` 表示JSON数据，`image/png` 表示PNG图片等。

如果状态码是301或302，浏览器会重定向到新的地址。这意味着它会再次发送一个新的HTTP请求到新的地址。

### 2. **处理响应数据**

根据响应头中的内容类型，浏览器会采取不同的操作：

- **字节流类型**：比如文件下载时，浏览器会将请求提交给下载管理器。
- **HTML类型**：如果内容类型是`text/html`，浏览器会开始解析HTML内容，进入渲染流程。

### 3. **解析HTML文件**

浏览器解析HTML文档并构建DOM树（Document Object Model Tree）。

- **DOM树**：是HTML文档的树状结构，表示页面的内容和结构。每个HTML标签都会成为DOM树中的一个节点。

### 4. **解析CSS**

同时，浏览器会解析与HTML相关联的CSS文件，进行样式计算。

- **CSSOM树**：CSS Object Model Tree，表示样式的树状结构。浏览器会根据CSS规则计算每个DOM节点的样式。

### 5. **构建渲染树**

浏览器将DOM树和CSSOM树结合，创建渲染树（Render Tree）。

- **渲染树**：是一个只包含需要渲染的节点的树。它会包含每个节点的内容和样式，但不会包含不显示的节点（例如`display: none`的节点）。

### 6. **布局（Layout）**

浏览器会根据渲染树计算每个节点在屏幕上的确切位置和大小。这一步叫做布局（也称为“回流”）。

### 7. **绘制（Paint）**

浏览器会将渲染树中的节点绘制到屏幕上。这一步叫做绘制。浏览器会依次绘制背景、边框、文本、图像等。

### 总结

- **解析响应头**：检查状态码和内容类型，决定下一步操作。
- **处理响应数据**：如果是HTML，开始解析。
- **解析HTML文件**：创建DOM树。
- **解析CSS**：创建CSSOM树，计算样式。
- **构建渲染树**：结合DOM和CSSOM，创建渲染树。
- **布局**：计算每个节点的确切位置和大小。
- **绘制**：将节点绘制到屏幕上，完成页面展示。